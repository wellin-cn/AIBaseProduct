# AI编程工具与开发者角色转变

## 背景

Cursor等AI编码工具已经可以通过大规模的上下文自动（半自动）捕获，实现相对完备的代码生成能力。

当前的开发者把精力/资源投入在上下文/领域知识的完善上带来的产出比其它方面的投入都要高。因此，从长远来看开发者在开发过程的角色应该从"开发者"转为"知识库管理者"。

## 目标

- 尝试给开发者一种新的角色，这种角色下，开发者更关注在代码供应链上AI编码工具不擅长，但却很有必要的部分。
- 项目更具有"AI可用性"（这里定义这个概念为：让项目更容易被AI分析，被AI改造，符合AI的"口味"）
- 理论上面对新的需求，开发者仅仅需要编写knowledge文件，不应该写任意一行代码。
- 在新的角色下，开发者的单位资源产出更高。

### AI可用性衡量标准

为了更好地评估项目的"AI可用性"，建议建立以下衡量标准：

- **AI理解准确率**：AI能够正确理解项目需求和业务逻辑的比例
- **代码生成一致性**：对同一需求多次生成代码的一致性程度
- **知识库覆盖度**：知识库对项目关键信息的覆盖程度
- **AI实现成功率**：AI直接实现需求无需人工干预的成功比例

## 实践

### 开发者优势

相比于AI，目前开发者仍然在项目的知识理解，业务背景上具有一定优势。开发者阅读了大量PRD，知道历史上一些开发过程的前因后果。

而这部分内容是AI通过无差别阅读项目代码是难以感知到的。

除了业务背景理解，开发者还应该关注以下AI相对薄弱的领域：
- **代码质量审查**：确保AI生成代码的质量和规范性
- **安全性考虑**：识别和处理潜在的安全风险
- **性能优化决策**：基于实际使用场景的性能优化
- **技术债务管理**：平衡开发速度与代码可维护性

因此开发者需要积极主动维护项目的知识库。

### 维护知识库

知识库应该具有以下特征：

- 具有合理的结构，方便自然人和AI阅读。
- 知识库包含技术领域和业务领域知识
- 知识库能展示出项目的开发历程

### 知识库结构示例

一种可能的实践：在项目下新建一个knowledge目录，里面以markdown语法，bullet格式一条条命题补充。

```
knowledge/
├── common/
│   ├── index.mdx
│   ├── lib.mdx
│   └── baseData/
├── architecture/           # 架构设计文档
│   ├── system-overview.mdx
│   ├── data-flow.mdx
│   └── component-design.mdx
├── conventions/           # 编码规范和约定
│   ├── naming-rules.mdx
│   ├── code-style.mdx
│   └── git-workflow.mdx
├── dependencies/          # 依赖关系说明
│   ├── external-apis.mdx
│   ├── third-party-libs.mdx
│   └── internal-services.mdx
├── troubleshooting/       # 常见问题解决方案
│   ├── debugging-guide.mdx
│   └── faq.mdx
├── features/
│   ├── done/
│   └── doing/
├── 20250312-addReportForVoipPage/
│   ├── index.mdx
│   ├── prd/
│   └── ui/
│       └── 1.png
└── 20250201-addAiFilterSDK/
    ├── index.mdx
    ├── prd/
    └── ui/
```

部分内容说明：
- features目录下的done目录放置的是已经完成的功能
- 项目是多页项目，每个页面分别在src/pages目录下

对于开发者和AI都可以通过常常阅读知识库完成项目的理解，事实上，开发者应该拥有这样一种视角：我们自然人（生物人）实际上真正维护的是knowledge这个项目，而src下的资源是AI编码工具"build"后的产出，理论上我们不需要看src的资源，就像你不用看dist目录下的资源一样，而之所以我们项目删除（gitignore）了dist目录但暂时还没有删除src目录，是因为对同一个知识库进行一次AI编码后的输出暂时还不稳定，即AI构建不唯一。

### 接手一个项目

当你接受一个项目的时候，直接阅读knowledge目录，理论上它写的足够好的话，可以快速让你看清整个项目的结构，如果不行，那么让AI引用knowledge和src两个目录一起为你解读。

### 应对一个需求

现在你已经熟悉了一个需求，只需要在对应的knowledge目录下编写feature文件。

feature文件一般而言就是消化后的PRD，让AI能读懂背景知识。

#### Feature文件标准模板

为确保一致性，建议使用以下模板：

```markdown
# 功能名称

- **需求时间**: YYYY-MM-DD
- **优先级**: 高/中/低
- **预估工作量**: X天
- **背景知识**: 详细的业务背景和技术背景
- **需求描述**: 具体的功能需求
- **验收标准**: 明确的验收条件
- **技术约束**: 相关的技术限制或要求
- **依赖项**: 其他功能或服务的依赖关系
```

#### 质量检查机制

- **知识库审查**：每个feature文件需要经过同行review
- **版本控制**：使用git管理knowledge目录的变更
- **定期清理**：每月检查并清理过时的知识条目

#### 需求项目示例

```
**添加进入页面埋点**

- **需求时间**: 2025-07-30
- **背景知识**: 对于VoipActivity页面，需要在页面进入时通过xxx插件完成进入页面的打点
- **需求**: 在进入页面时，通过xxx插件完成进入页面的打点
```
#### 让AI实现

根据你的偏好，用cursor或者类似的功能去添加knowledge目录，指明你的feature文件，然后just apply it.

### 验收

测试验收一下需求的功能，如果有其它环节，例如bug检查，git commit自动化，那就去做，没有问题就提交吧。当需求验收完成后，记得把feature的名字添加done的前缀，标记成为历史知识。

通过下图可以看到，AI完成了两个需求实现，关联了上报时机并编写了illusory插件的自测case，需求自测通过。

## 角色转变策略

### 渐进式转变

建议采用分阶段的转变策略：

**第一阶段**（1-2个月）：
- 建立基础知识库结构
- 团队熟悉新的工作流程
- 在小型功能上试点

**第二阶段**（3-6个月）：
- 扩大AI辅助开发的范围
- 完善知识库内容
- 建立质量控制机制

**第三阶段**（6个月以上）：
- 实现大部分开发工作由AI完成
- 开发者专注于知识库管理和架构决策
- 建立成熟的评估和优化体系

### 适应性考虑

不同技能水平的开发者需要不同的适应策略：
- **资深开发者**：重点转向架构设计和知识体系建设
- **中级开发者**：平衡传统开发技能和知识管理能力
- **初级开发者**：可以更快适应AI辅助的开发模式

## 风险管理

### 主要风险和缓解措施

**1. 知识库维护成本过高**
- **风险**：知识库可能变得过于庞大难以维护
- **缓解措施**：
  - 建立知识库的精简原则
  - 实施定期清理机制
  - 使用自动化工具检测重复内容

**2. AI生成代码的不一致性**
- **风险**：同一需求多次生成的代码差异较大
- **缓解措施**：
  - 建立代码review机制
  - 制定详细的编码规范
  - 使用代码质量检查工具

**3. 团队协作冲突**
- **风险**：不同开发者维护的知识库可能存在冲突
- **缓解措施**：
  - 建立知识库的协作规范
  - 实施merge策略和冲突解决流程
  - 定期进行团队同步会议

**4. 技能退化风险**
- **风险**：过度依赖AI可能导致编程技能退化
- **缓解措施**：
  - 保持对复杂技术问题的直接参与
  - 定期进行技术学习和分享
  - 在关键模块保持人工代码review

## 成功案例

### 完整实践案例：添加用户行为分析功能

**需求背景**：产品需要在用户页面添加行为分析功能，收集用户操作数据用于产品优化。

**知识库准备**：
1. 在`knowledge/20250315-userBehaviorAnalytics/`创建功能目录
2. 编写feature文件包含：
   - 数据收集需求
   - 隐私保护要求
   - 技术选型约束
   - UI/UX设计要求

**AI实现过程**：
1. AI基于knowledge文件理解需求
2. 自动生成数据收集组件
3. 实现隐私保护机制
4. 创建配置管理界面

**验收结果**：
- 功能实现100%符合需求
- 代码质量通过review
- 性能测试达标
- 开发时间比传统方式减少60%

## 工具和度量

### 推荐工具集成

- **IDE插件**：开发knowledge文件的语法高亮和自动补全
- **CI/CD集成**：自动检查knowledge文件的完整性
- **搜索工具**：快速查找知识库中的相关信息
- **版本管理**：知识库变更的可视化追踪

### 效果度量指标

**开发效率指标**：
- 需求到交付的时间缩短比例
- AI实现成功率（无需人工干预）
- 代码review发现问题的减少比例

**知识库质量指标**：
- 知识库覆盖度（关键业务流程的覆盖比例）
- 知识库使用频率
- 知识条目的有效性评分

**代码质量指标**：
- bug率变化
- 代码重复度
- 技术债务积累速度

## 实施建议

1. **先试点后推广**：在小型项目中验证模式的可行性
2. **持续迭代**：根据实践反馈不断优化知识库结构和工作流程
3. **团队培训**：确保所有成员理解新的工作模式
4. **建立社区**：与其他采用类似模式的团队交流经验

这种开发模式代表了软件开发的未来趋势，但需要谨慎实施并持续优化才能发挥最大价值。